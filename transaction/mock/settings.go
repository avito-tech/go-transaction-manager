// Code generated by MockGen. DO NOT EDIT.
// Source: settings.go

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"
	time "time"

	transaction "github.com/avito-tech/go-transaction-manager/transaction"
	gomock "github.com/golang/mock/gomock"
)

// MockSettings is a mock of Settings interface.
type MockSettings struct {
	ctrl     *gomock.Controller
	recorder *MockSettingsMockRecorder
}

// MockSettingsMockRecorder is the mock recorder for MockSettings.
type MockSettingsMockRecorder struct {
	mock *MockSettings
}

// NewMockSettings creates a new mock instance.
func NewMockSettings(ctrl *gomock.Controller) *MockSettings {
	mock := &MockSettings{ctrl: ctrl}
	mock.recorder = &MockSettingsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSettings) EXPECT() *MockSettingsMockRecorder {
	return m.recorder
}

// Cancelable mocks base method.
func (m *MockSettings) Cancelable() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cancelable")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Cancelable indicates an expected call of Cancelable.
func (mr *MockSettingsMockRecorder) Cancelable() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancelable", reflect.TypeOf((*MockSettings)(nil).Cancelable))
}

// CancelableOrNil mocks base method.
func (m *MockSettings) CancelableOrNil() *bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CancelableOrNil")
	ret0, _ := ret[0].(*bool)
	return ret0
}

// CancelableOrNil indicates an expected call of CancelableOrNil.
func (mr *MockSettingsMockRecorder) CancelableOrNil() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelableOrNil", reflect.TypeOf((*MockSettings)(nil).CancelableOrNil))
}

// CtxKey mocks base method.
func (m *MockSettings) CtxKey() transaction.CtxKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CtxKey")
	ret0, _ := ret[0].(transaction.CtxKey)
	return ret0
}

// CtxKey indicates an expected call of CtxKey.
func (mr *MockSettingsMockRecorder) CtxKey() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CtxKey", reflect.TypeOf((*MockSettings)(nil).CtxKey))
}

// CtxKeyOrNil mocks base method.
func (m *MockSettings) CtxKeyOrNil() *transaction.CtxKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CtxKeyOrNil")
	ret0, _ := ret[0].(*transaction.CtxKey)
	return ret0
}

// CtxKeyOrNil indicates an expected call of CtxKeyOrNil.
func (mr *MockSettingsMockRecorder) CtxKeyOrNil() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CtxKeyOrNil", reflect.TypeOf((*MockSettings)(nil).CtxKeyOrNil))
}

// EnrichBy mocks base method.
func (m *MockSettings) EnrichBy(external transaction.Settings) transaction.Settings {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnrichBy", external)
	ret0, _ := ret[0].(transaction.Settings)
	return ret0
}

// EnrichBy indicates an expected call of EnrichBy.
func (mr *MockSettingsMockRecorder) EnrichBy(external interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnrichBy", reflect.TypeOf((*MockSettings)(nil).EnrichBy), external)
}

// IsReadOnly mocks base method.
func (m *MockSettings) IsReadOnly() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReadOnly")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReadOnly indicates an expected call of IsReadOnly.
func (mr *MockSettingsMockRecorder) IsReadOnly() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReadOnly", reflect.TypeOf((*MockSettings)(nil).IsReadOnly))
}

// IsReadOnlyOrNil mocks base method.
func (m *MockSettings) IsReadOnlyOrNil() *bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReadOnlyOrNil")
	ret0, _ := ret[0].(*bool)
	return ret0
}

// IsReadOnlyOrNil indicates an expected call of IsReadOnlyOrNil.
func (mr *MockSettingsMockRecorder) IsReadOnlyOrNil() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReadOnlyOrNil", reflect.TypeOf((*MockSettings)(nil).IsReadOnlyOrNil))
}

// Propagation mocks base method.
func (m *MockSettings) Propagation() transaction.Propagation {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Propagation")
	ret0, _ := ret[0].(transaction.Propagation)
	return ret0
}

// Propagation indicates an expected call of Propagation.
func (mr *MockSettingsMockRecorder) Propagation() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Propagation", reflect.TypeOf((*MockSettings)(nil).Propagation))
}

// PropagationOrNil mocks base method.
func (m *MockSettings) PropagationOrNil() *transaction.Propagation {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PropagationOrNil")
	ret0, _ := ret[0].(*transaction.Propagation)
	return ret0
}

// PropagationOrNil indicates an expected call of PropagationOrNil.
func (mr *MockSettingsMockRecorder) PropagationOrNil() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PropagationOrNil", reflect.TypeOf((*MockSettings)(nil).PropagationOrNil))
}

// SetCancelable mocks base method.
func (m *MockSettings) SetCancelable(arg0 *bool) transaction.Settings {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCancelable", arg0)
	ret0, _ := ret[0].(transaction.Settings)
	return ret0
}

// SetCancelable indicates an expected call of SetCancelable.
func (mr *MockSettingsMockRecorder) SetCancelable(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCancelable", reflect.TypeOf((*MockSettings)(nil).SetCancelable), arg0)
}

// SetCtxKey mocks base method.
func (m *MockSettings) SetCtxKey(arg0 *transaction.CtxKey) transaction.Settings {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCtxKey", arg0)
	ret0, _ := ret[0].(transaction.Settings)
	return ret0
}

// SetCtxKey indicates an expected call of SetCtxKey.
func (mr *MockSettingsMockRecorder) SetCtxKey(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCtxKey", reflect.TypeOf((*MockSettings)(nil).SetCtxKey), arg0)
}

// SetIsReadOnly mocks base method.
func (m *MockSettings) SetIsReadOnly(arg0 *bool) transaction.Settings {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetIsReadOnly", arg0)
	ret0, _ := ret[0].(transaction.Settings)
	return ret0
}

// SetIsReadOnly indicates an expected call of SetIsReadOnly.
func (mr *MockSettingsMockRecorder) SetIsReadOnly(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetIsReadOnly", reflect.TypeOf((*MockSettings)(nil).SetIsReadOnly), arg0)
}

// SetPropagation mocks base method.
func (m *MockSettings) SetPropagation(arg0 *transaction.Propagation) transaction.Settings {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetPropagation", arg0)
	ret0, _ := ret[0].(transaction.Settings)
	return ret0
}

// SetPropagation indicates an expected call of SetPropagation.
func (mr *MockSettingsMockRecorder) SetPropagation(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPropagation", reflect.TypeOf((*MockSettings)(nil).SetPropagation), arg0)
}

// SetTimeout mocks base method.
func (m *MockSettings) SetTimeout(arg0 *time.Duration) transaction.Settings {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTimeout", arg0)
	ret0, _ := ret[0].(transaction.Settings)
	return ret0
}

// SetTimeout indicates an expected call of SetTimeout.
func (mr *MockSettingsMockRecorder) SetTimeout(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTimeout", reflect.TypeOf((*MockSettings)(nil).SetTimeout), arg0)
}

// TimeoutOrNil mocks base method.
func (m *MockSettings) TimeoutOrNil() *time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TimeoutOrNil")
	ret0, _ := ret[0].(*time.Duration)
	return ret0
}

// TimeoutOrNil indicates an expected call of TimeoutOrNil.
func (mr *MockSettingsMockRecorder) TimeoutOrNil() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimeoutOrNil", reflect.TypeOf((*MockSettings)(nil).TimeoutOrNil))
}
